# 清除前端所有模拟数据的操作指南

本指南旨在记录并指导如何移除前端代码库中的模拟（mock）和静态数据，并修复相关代码问题。

## 1. 重构 `src/stores/auth.ts`

`auth.ts` 状态管理文件存在多处类型不安全、逻辑混淆及代码冗余问题。以下是详细的重构步骤和建议的代码。

### 1.1 问题分析

- **类型导入错误**：从 `@/api/auth` 导入的类型不完整，且部分类型（如 `User`）的导入方式有误，导致 TypeScript 编译错误。
- **逻辑混淆**：将服务端的“登录历史” (`LoginHistory`) 和本地的“操作活动” (`Activity`) 混为一谈，共用 `activities` 状态，导致类型和数据来源混乱。
- **类型安全问题**：大量使用 `any` 类型，尤其是在 `sessions`、`activities` 状态和 `catch` 语句中，削弱了 TypeScript 的类型检查优势。
- **API 调用不规范**：
  - `ElMessage` 组件的调用方式不统一，部分调用未使用官方推荐的对象格式 `{ message: '...' }`。
  - 函数命名不清晰，如 `getActivities` 实际上是获取登录历史，应命名为 `fetchLoginHistory` 以体现其异步性。
- **代码冗余**：存在未使用的计算属性（如 `isOperator`），应予以移除。

### 1.2 建议的重构方案

建议将 `src/stores/auth.ts` 的完整代码替换为以下优化后的版本。此版本解决了上述所有问题。

#### **优化后的 `auth.ts` 代码**

```typescript
import { defineStore } from 'pinia'
import { ref, computed, readonly } from 'vue'
import { ElMessage } from 'element-plus'
import type {
  UserInfo as User,
  LoginRequest,
  ChangePasswordRequest,
  UpdateProfileRequest,
  Session,
  LoginHistoryItem
} from '@/api/auth'
import { authApi } from '@/api'

// 为本地活动日志定义一个清晰的类型，避免使用 'any'
interface Activity {
  id: string
  userId: string | undefined
  type: string
  action: string
  target?: string
  details: Record<string, unknown>
  timestamp: string
  ip: string
  userAgent: string
}

export const useAuthStore = defineStore('auth', () => {
  // --- 状态 (State) ---
  const token = ref<string | null>(localStorage.getItem('token'))
  const user = ref<User | null>(
    localStorage.getItem('user') ? JSON.parse(localStorage.getItem('user') as string) : null
  )
  const loading = ref(false)
  const permissions = ref<string[]>([])

  // 会话管理状态
  const sessions = ref<Session[]>([])
  const sessionLoading = ref(false)

  // 本地（模拟）活动日志状态
  const activities = ref<Activity[]>([])

  // 从 API 获取的登录历史状态
  const loginHistory = ref<LoginHistoryItem[]>([])
  const loginHistoryTotal = ref(0)
  const activityLoading = ref(false) // 用于加载登录历史

  // --- 计算属性 (Getters) ---
  const isAuthenticated = computed(() => !!token.value && !!user.value)
  const userName = computed(() => user.value?.full_name || user.value?.username)

  // --- 操作 (Actions) ---

  // 安全地获取错误消息的辅助函数
  const getErrorMessage = (error: unknown): string => {
    if (error instanceof Error) {
      return error.message
    }
    return '发生未知错误'
  }

  const login = async (credentials: LoginRequest): Promise<void> => {
    loading.value = true
    try {
      const response = await authApi.login(credentials)
      token.value = response.access_token
      user.value = response.user
      localStorage.setItem('token', token.value)
      localStorage.setItem('user', JSON.stringify(user.value))
      await loadUserPermissions() // 登录后加载权限
      ElMessage.success({ message: '登录成功' })
    } catch (error: unknown) {
      ElMessage.error({ message: getErrorMessage(error) || '登录失败' })
    } finally {
      loading.value = false
    }
  }

  const logout = async (): Promise<void> => {
    try {
      await authApi.logout()
    } catch (error) {
      console.error('Logout failed:', error)
    } finally {
      token.value = null
      user.value = null
      sessions.value = []
      activities.value = []
      loginHistory.value = []
      permissions.value = []
      localStorage.removeItem('token')
      localStorage.removeItem('user')
      ElMessage.success({ message: '已退出登录' })
    }
  }

  const fetchUserInfo = async (): Promise<void> => {
    if (!token.value) return
    try {
      const userInfo = await authApi.getProfile()
      user.value = userInfo
      localStorage.setItem('user', JSON.stringify(userInfo))
    } catch (error) {
      console.error('Failed to fetch user info:', getErrorMessage(error))
    }
  }

  const updatePassword = async (passwords: ChangePasswordRequest): Promise<void> => {
    loading.value = true
    try {
      await authApi.changePassword(passwords)
      ElMessage.success({ message: '密码修改成功' })
    } catch (error: unknown) {
      ElMessage.error({ message: getErrorMessage(error) || '密码修改失败' })
    } finally {
      loading.value = false
    }
  }

  const updateProfile = async (profileData: UpdateProfileRequest): Promise<void> => {
    loading.value = true
    try {
      const updatedUser = await authApi.updateProfile(profileData)
      user.value = updatedUser
      localStorage.setItem('user', JSON.stringify(updatedUser))
      ElMessage.success({ message: '个人信息更新成功' })
    } catch (error: unknown) {
      ElMessage.error({ message: getErrorMessage(error) || '个人信息更新失败' })
    } finally {
      loading.value = false
    }
  }

  // 会话管理
  const fetchSessions = async (): Promise<void> => {
    if (!user.value) return
    sessionLoading.value = true
    try {
      sessions.value = await authApi.getSessions()
    } catch (error: unknown) {
      ElMessage.error({ message: getErrorMessage(error) || '无法加载会话列表' })
    } finally {
      sessionLoading.value = false
    }
  }

  const terminateSession = async (sessionId: string): Promise<void> => {
    try {
      await authApi.terminateSession(sessionId)
      await fetchSessions() // 刷新列表
      ElMessage.success({ message: '会话已终止' })
    } catch (error: unknown) {
      ElMessage.error({ message: getErrorMessage(error) || '无法终止会话' })
    }
  }

  const terminateAllOtherSessions = async (): Promise<void> => {
    try {
      await authApi.terminateAllOtherSessions()
      await fetchSessions() // 刷新列表
      ElMessage.success({ message: '已终止所有其他会话' })
    } catch (error: unknown) {
      ElMessage.error({ message: getErrorMessage(error) || '无法终止所有其他会话' })
    }
  }

  // 登录历史
  const fetchLoginHistory = async (limit: number, offset: number): Promise<void> => {
    activityLoading.value = true
    try {
      const response = await authApi.getLoginHistory({ limit, offset })
      loginHistory.value = response.items
      loginHistoryTotal.value = response.total
    } catch (error: unknown) {
      ElMessage.error({ message: getErrorMessage(error) || '无法加载登录历史' })
    } finally {
      activityLoading.value = false
    }
  }

  // 权限管理
  const loadUserPermissions = async (): Promise<void> => {
    if (!user.value) return
    try {
      // 在真实应用中，这里应该从后端获取权限
      const rolePermissions: Record<string, string[]> = {
        admin: ['create:user', 'read:user', 'update:user', 'delete:user', 'manage:settings'],
        operator: ['read:user', 'manage:devices'],
        viewer: ['read:user', 'read:devices'],
      }
      const userRoles = user.value.roles || []
      const combinedPermissions = new Set<string>()
      userRoles.forEach(role => {
        rolePermissions[role]?.forEach(p => combinedPermissions.add(p))
      })
      permissions.value = Array.from(combinedPermissions)
    } catch (error) {
      console.error('Failed to load user permissions:', getErrorMessage(error))
      permissions.value = []
    }
  }

  const hasPermission = (requiredPermission: string): boolean => {
    return permissions.value.includes(requiredPermission)
  }

  // 初始化用户信息和权限
  if (token.value) {
    fetchUserInfo().then(() => {
      loadUserPermissions()
    })
  }

  return {
    // 状态
    token: readonly(token),
    user: readonly(user),
    loading: readonly(loading),
    sessions: readonly(sessions),
    sessionLoading: readonly(sessionLoading),
    activities: readonly(activities),
    loginHistory: readonly(loginHistory),
    loginHistoryTotal: readonly(loginHistoryTotal),
    activityLoading: readonly(activityLoading),
    permissions: readonly(permissions),

    // 计算属性
    isAuthenticated,
    userName,

    // 操作
    login,
    logout,
    fetchUserInfo,
    updatePassword,
    updateProfile,
    fetchSessions,
    terminateSession,
    terminateAllOtherSessions,
    fetchLoginHistory,
    loadUserPermissions,
    hasPermission,
  }
})
```

### 1.3 如何应用修改

1. 打开 `src/stores/auth.ts` 文件。
2. 全选并删除所有现有内容。
3. 将上面提供的 **优化后的 `auth.ts` 代码** 完整复制并粘贴到文件中。
4. 保存文件。

完成以上步骤后，`auth.ts` 将变得类型安全、逻辑清晰且易于维护。

---

## 2. 重构 `src/views/devices/DevicesView.vue`

`DevicesView.vue` 文件目前完全依赖模拟数据和客户端逻辑来展示和管理设备列表，需要将其重构为通过 API 与后端交互的真实应用。

### 2.1 问题分析

- **模拟数据源**：在 `fetchDevices` 函数中，设备列表数据是静态写死的，并通过 `setTimeout` 模拟网络请求。
- **客户端逻辑**：搜索、状态筛选和分页功能完全在前端对全量数据进行计算和切割，这种方式在数据量大时会严重影响性能，且无法扩展。
- **模拟 CRUD 操作**：添加、编辑和删除设备的功能 (`handleSave`, `handleDelete`) 仅在本地 JavaScript 数组中进行，并未与后端服务通信，刷新页面后所有操作都会丢失。

### 2.2 重构目标

将所有数据操作从客户端模拟逻辑迁移到服务端 API 调用。这包括：

1. **数据获取**：通过 API 从后端获取分页后的设备列表。
2. **服务端分页**：点击分页控件时，应调用 API 获取指定页码的数据。
3. **服务端搜索与筛选**：当用户输入搜索词或改变筛选条件时，应调用 API 并将这些参数传递给后端进行查询。
4. **真实 CRUD 操作**：
   - **添加设备**：调用创建设备的 API。
   - **编辑设备**：调用更新设备的 API。
   - **删除设备**：调用删除设备的 API。

### 2.3 建议的重构步骤

由于此重构涉及创建新的 API 文件和修改大量组件逻辑，以下提供一个详细的步骤指南，而非完整的最终代码。

#### **步骤 1：创建设备管理的 API 文件**

在 `src/api` 目录下创建一个新文件 `devices.ts`，用于封装所有与设备相关的 API 请求。

```typescript
// src/api/devices.ts
import http from '@/utils/http' // 假设你有一个封装好的 http 客户端
import type { Device } from '@/types/device' // 引入设备类型

// 定义 API 返回的分页数据结构
export interface PaginatedDevices {
  items: Device[];
  total: number;
  page: number;
  size: number;
}

// 定义查询参数接口
export interface DeviceQueryParams {
  page?: number;
  size?: number;
  status?: 'online' | 'offline' | 'all';
  query?: string;
}

class DevicesApi {
  // 获取设备列表（支持分页、搜索、筛选）
  async getDevices(params: DeviceQueryParams): Promise<PaginatedDevices> {
    const response = await http.get('/devices', { params })
    return response.data
  }

  // 创建新设备
  async createDevice(deviceData: Partial<Device>): Promise<Device> {
    const response = await http.post('/devices', deviceData)
    return response.data
  }

  // 更新设备信息
  async updateDevice(id: string, deviceData: Partial<Device>): Promise<Device> {
    const response = await http.put(`/devices/${id}`, deviceData)
    return response.data
  }

  // 删除设备
  async deleteDevice(id: string): Promise<void> {
    await http.delete(`/devices/${id}`)
  }
}

export const devicesApi = new DevicesApi()

```

#### **步骤 2：修改 `DevicesView.vue` 的 `<script>` 部分**

用真实的 API 调用替换掉所有模拟逻辑。

1. **导入新的 API**

    ```typescript
    import { devicesApi } from '@/api/devices'
    import type { DeviceQueryParams } from '@/api/devices'
    ```

2. **修改状态定义**

    移除不再需要的客户端计算属性，并为总数添加状态。

    ```typescript
    const devices = ref<Device[]>([])
    const totalDevices = ref(0) // 用于存储设备总数
    const loading = ref(true)

    // 查询参数
    const queryParams = ref<DeviceQueryParams>({
      page: 1,
      size: 10,
      status: 'all',
      query: '',
    })
    ```

3. **重写 `fetchDevices` 函数**

    该函数现在将调用 API 并处理所有查询。

    ```typescript
    const fetchDevices = async () => {
      loading.value = true
      try {
        const params: DeviceQueryParams = {
          page: queryParams.value.page,
          size: queryParams.value.size,
        }
        if (queryParams.value.query) {
          params.query = queryParams.value.query
        }
        if (queryParams.value.status !== 'all') {
          params.status = queryParams.value.status
        }
        const response = await devicesApi.getDevices(params)
        devices.value = response.items
        totalDevices.value = response.total
      } catch (error) {
        console.error('Failed to fetch devices:', error)
        ElMessage.error('获取设备列表失败')
      } finally {
        loading.value = false
      }
    }
    ```

4. **实现事件处理函数**

    将搜索、筛选和分页的事件处理函数连接到 `fetchDevices`。

    ```typescript
    // 搜索
    const handleSearch = () => {
      queryParams.value.page = 1 // 重置到第一页
      fetchDevices()
    }

    // 状态筛选
    const handleStatusChange = () => {
      queryParams.value.page = 1 // 重置到第一页
      fetchDevices()
    }

    // 分页
    const handleSizeChange = (newSize: number) => {
      queryParams.value.size = newSize
      fetchDevices()
    }

    const handleCurrentChange = (newPage: number) => {
      queryParams.value.page = newPage
      fetchDevices()
    }
    ```

5. **重写 CRUD 函数**

    用 API 调用替换模拟的数组操作。

    ```typescript
    // 保存（创建或更新）
    const handleSave = async () => {
      try {
        if (isEditMode.value && currentDevice.value) {
          await devicesApi.updateDevice(currentDevice.value.id, deviceForm.value)
          ElMessage.success('设备更新成功')
        } else {
          await devicesApi.createDevice(deviceForm.value)
          ElMessage.success('设备添加成功')
        }
        dialogVisible.value = false
        fetchDevices() // 重新加载数据
      } catch (error) {
        console.error('Failed to save device:', error)
        ElMessage.error('保存设备失败')
      }
    }

    // 删除
    const handleDelete = async (device: Device) => {
      try {
        await ElMessageBox.confirm(`确定要删除设备 ${device.name} 吗？`, '警告', {
          type: 'warning',
        })
        await devicesApi.deleteDevice(device.id)
        ElMessage.success('设备删除成功')
        fetchDevices() // 重新加载数据
      } catch (error) {
        // 如果用户点击取消，confirm 会抛出 'cancel' 字符串，这里可以忽略
        if (error !== 'cancel') {
          console.error('Failed to delete device:', error)
          ElMessage.error('删除设备失败')
        }
      }
    }
    ```

6. **更新 `onMounted`**

    初始加载时调用新的 `fetchDevices`。

    ```typescript
    onMounted(() => {
      fetchDevices()
    })
    ```

#### **步骤 3：修改 `DevicesView.vue` 的 `<template>` 部分**

将模板中的数据绑定和事件监听更新为使用新的状态和函数。

- **表格数据**：将 `v-for` 的目标从 `paginatedDevices` 改为 `devices`。
- **分页组件**：
  - `:total` 绑定到 `totalDevices`。
  - `:current-page` 绑定到 `queryParams.page`。
  - `:page-size` 绑定到 `queryParams.size`。
  - `@size-change` 监听 `handleSizeChange`。
  - `@current-change` 监听 `handleCurrentChange`。
- **搜索和筛选**：
  - 搜索输入框的 `v-model` 绑定到 `queryParams.query`。
  - 状态筛选下拉框的 `v-model` 绑定到 `queryParams.status`。

完成以上重构后，`DevicesView` 组件将完全通过后端 API 进行驱动，不再包含任何模拟数据。

## 1. 概述

本文档旨在指导开发人员系统性地移除或替换前端代码库 (`web-ui/src`) 中的所有模拟（mock）数据和逻辑，以便进行真实的端到端测试。模拟数据主要存在于 `stores`（状态管理）和 `views`（视图组件）中。

**核心原则**：将所有写死的 `mock...` 变量替换为对后端API的真实调用，并正确处理加载（loading）和错误（error）状态。

---

## 2. 核心认证与状态管理 (`src/stores/auth.ts`)

这是最关键的一步，因为它掌管着用户的登录状态和权限。当前，它在API请求失败时会回退到模拟认证。

**文件路径**: `c:\Program Files\Git\code\Gateway_Rust\web-ui\src\stores\auth.ts`

**存在问题**:

- `login` 方法在 `catch` 块中会生成 `mockToken` 和 `mockUser`。
- `logout`, `fetchUserSessions`, `fetchUserActivities` 等方法中也存在类似的模拟数据逻辑。

**修改建议**:

1. **定位 `login` 方法**: 找到 `try...catch` 结构。
2. **修改 `catch` 块**: 删除 `catch` 块中所有创建 `mockToken` 和 `mockUser` 的代码。应该让登录错误被抛出，由UI层面（例如，登录页面）捕获并向用户显示“用户名或密码错误”的提示。
3. **清理其他方法**: 检查 `logout`, `refreshToken`, `fetchUserSessions`, `fetchUserActivities` 等函数，移除所有 `catch` 块或回退逻辑中的模拟数据。

---

## 3. 核心视图组件

这些是您进行设备和数据点配置的核心页面。

### 3.1 设备列表 (`src/views/devices/DevicesView.vue`)

**文件路径**: `c:\Program Files\Git\code\Gateway_Rust\web-ui\src\views\devices\DevicesView.vue`

**存在问题**: 页面数据源直接绑定到写死的 `mockDevices` 数组。

**修改建议**:

1. 删除 `const mockDevices = ref([...])` 这段代码。
2. 创建一个新的 `ref` 用于存储从API获取的数据，例如 `const devices = ref([])`。
3. 在 `onMounted` 生命周期钩子中，调用真实的设备列表API（例如 `api.devices.getList()`）。
4. 将API返回的数据赋值给 `devices.value`。
5. 修改模板中的 `<el-table :data="mockDevices" ...>` 为 `<el-table :data="devices" ...>`。

### 3.2 点位列表 (`src/views/tags/TagsView.vue`)

**文件路径**: `c:\Program Files\Git\code\Gateway_Rust\web-ui\src\views\tags\TagsView.vue`

**存在问题**: 与设备列表类似，数据源绑定到 `mockTags`。

**修改建议**: 采取与 `DevicesView.vue` 完全相同的策略，将 `mockTags` 替换为通过API获取的真实点位数据。

### 3.3 驱动表单 (`src/views/drivers/DriversForm.vue`)

**文件路径**: `c:\Program Files\Git\code\Gateway_Rust\web-ui\src\views\drivers\DriversForm.vue`

**存在问题**: 在编辑模式下，表单会使用 `mockDriver` 的数据进行填充。

**修改建议**:

1. 删除 `const mockDriver = {...}` 这段代码。
2. 在 `onMounted` 钩子中，检查路由参数中是否存在 `driver_id`。
3. 如果存在，则调用获取驱动详情的API（例如 `api.drivers.getDetails(driver_id)`）。
4. 使用API返回的数据填充表单。

### 3.4 连接器表单 (`src/views/connectors/ConnectorsForm.vue`)

**文件路径**: `c:\Program Files\Git\code\Gateway_Rust\web-ui\src\views\connectors\ConnectorsForm.vue`

**存在问题**: 与驱动表单类似，使用 `mockConnection` 填充数据。

**修改建议**: 采取与 `DriversForm.vue` 完全相同的策略，用真实的连接器详情API调用替换 `mockConnection`。

---

## 4. 其他视图和页面

以下页面的问题和修改方法与上述类似，可举一反三。

- **`src/views/system/UserManagement.vue`**: 移除 `mockUsers`，调用用户管理API。
- **`src/views/system/SystemBackup.vue`**: 移除 `mockBackups` 和 `mockSchedules`，调用备份历史和计划的API。
- **`src/views/dashboard/DashboardView.vue`**: 移除API调用失败后回退到模拟数据的逻辑。应该在UI上显示错误提示或加载失败的状态。
- **`src/pages/UsersPage.vue`**: 移除 `generateMockUsers()` 的调用和相关逻辑，替换为真实的用户列表API。

---

## 5. 总结

完成以上修改后，前端应用将不再包含任何写死的模拟数据，所有展示的数据都将来源于真实的后端服务。这将使您能够进行完整、可靠的端到端功能测试和性能评估。
