**段落 1（重新规划）：在 _Gateway_Rust_ 现有代码基础上，增量引入 **`web-gw-api`** 与 Vue 前端，完成从“裸网关”到“浏览器可配置网关”的最小闭环**

> 目标：**不改动** 既有采集链路（frame-bus、driver-manager、mqtt5 等），只增量添加 **Actix-Web HTTP+WS 服务** 与 **Vue 3 前端**，让现场工程师通过网页完成 **“设备-→-点位-→-驱动” 全流程配置与实时监控**。下文的路径均相对于仓库根目录；代码片段可直接粘贴。

---

### 1-A．增量目录结构

```
Gateway_Rust/
├─ core/
│  ├─ driver-manager/         # 已存在
│  ├─ frame-bus/              # 已存在
│  └─ web-gw-api/             # ➕ 新 crate（Actix 服务，bin）
│      ├─ src/
│      │   ├─ main.rs
│      │   ├─ bootstrap.rs    // 读取配置 + DI
│      │   ├─ config.rs       // 详见 1-B
│      │   ├─ dto.rs          // Web 可见结构体
│      │   ├─ routes/         // devices.rs tags.rs drivers.rs telemetry_ws.rs health.rs
│      │   └─ error.rs
│      └─ Cargo.toml
├─ web-ui/                    # ➕ Vue 3 + Vite + TS
│  ├─ package.json            // 见 1-G
│  └─ src/
│      ├─ api/                // axios 封装
│      ├─ stores/             // Pinia
│      ├─ components/
│      └─ pages/
│          ├─ Device.vue
│          ├─ Tag.vue
│          ├─ Driver.vue
│          └─ Dashboard.vue
└─ schema/
    └─ migrations/            # 已有，新增 0003_xxx.sql 建设备 & 点位表
```

- **Cargo workspace**：在根 `Cargo.toml` 追加 `"core/web-gw-api"` 到 `[workspace] members]`。

- **Docker**：顶层 `docker-compose.yml` 新增 `web-gw-api` 服务；前端由 Nginx 静态托管或 Vite Dev Server，本段只给骨架。


---

### 1-B．运行时配置结构 `config.rs`

```rust
#[derive(Debug, serde::Deserialize, Clone)]
pub struct ApiCfg {
    /// HTTP 监听, 默认 0.0.0.0:8080
    pub http_addr:      std::net::SocketAddr,
    /// WebSocket 路径, 默认 "/ws"
    pub ws_path:        String,
    /// 允许的前端源，支持通配
    pub cors_allowed:   Vec<String>,
    /// PostgreSQL DSN（元数据：设备、点位）
    pub pg_dsn:         String,
    /// InfluxDB base url
    pub influx_url:     String,
    /// 框架内部总线 addr（nats://）
    pub bus_url:        String,
    /// 驱动目录根
    pub drivers_dir:    std::path::PathBuf,
    /// log level
    pub log_level:      String,
}
```

_配置加载顺序_

1. 读取 `config/default.yaml → config/{ENV}.yaml`

2. `ENV` 变量覆盖（形如 `WEBGW_HTTP_ADDR=0.0.0.0:9000`）


---

### 1-C．`main.rs` 最小可运行示例

```rust
#[actix_web::main]
async fn main() -> anyhow::Result<()> {
    use actix_web::{App, HttpServer, middleware::Logger};
    tracing_subscriber::fmt::init();

    let cfg = bootstrap::load_cfg()?;
    let state = bootstrap::init_state(&cfg).await?;

    HttpServer::new(move || {
        App::new()
            .app_data(state.clone())
            .wrap(Logger::default())
            .wrap(state.cors())
            .configure(routes::register)      // 装配所有路由
    })
    .bind(cfg.http_addr)?
    .run()
    .await?;
    Ok(())
}
```

---

### 1-D．核心数据模型（`dto.rs` 摘要）

```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Device {
    pub id:          Uuid,
    pub name:        String,
    pub protocol:    ProtocolKind,   // ModbusTcp|OpcUa|Mqtt
    pub location:    Option<String>,
    pub created_at:  DateTime<Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TagPoint {
    pub id:         Uuid,
    pub device_id:  Uuid,
    pub address:    String,          // "40001"
    pub data_type:  TagDataType,     // Float|Int|Bool|String
    pub scaling:    Option<f64>,
    pub unit:       Option<String>,
}
```

> **约定**：所有前端/后端交互 JSON 均采用 `snake_case`；`ProtocolKind` & `TagDataType` 映射 PG 枚举类型，详见迁移脚本。

---

### 1-E．HTTP & WS 接口一览（MVP 3-4 必达）

|Method|Path|描述|Handler|
|---|---|---|---|
|`GET`|`/api/v1/health`|活性探针|`health::live`|
|`POST`|`/api/v1/devices`|新增设备|`devices::create`|
|`GET`|`/api/v1/devices`|分页列表|`devices::list`|
|`GET`|`/api/v1/devices/{id}`|详情|`devices::get`|
|`PUT`|`/api/v1/devices/{id}`|更新|`devices::update`|
|`DELETE`|`/api/v1/devices/{id}`|删除|`devices::delete`|
|`GET`|`/api/v1/tags`|条件查询|`tags::list`|
|`POST`|`/api/v1/tags`|新增点位|`tags::create`|
|`WS`|`/ws/telemetry`|实时数据流|`telemetry_ws::connect`|
|`GET`|`/api/v1/drivers`|驱动列表|`drivers::list`|
|`POST`|`/api/v1/drivers/upload`|上传+加载驱动|`drivers::upload`|
|`POST`|`/api/v1/drivers/{protocol}/reload`|热重载|`drivers::reload`|
|`DELETE`|`/api/v1/drivers/{protocol}`|卸载|`drivers::unload`|

⚠ **暂不包含身份鉴权** —— 全部路由在内网开放；上线前可再接入 JWT/RBAC（另起段落）。

---

### 1-F．数据库迁移 (PostgreSQL)

`schema/migrations/0003_init_device_tag.sql`

```sql
CREATE TYPE protocol_kind AS ENUM ('ModbusTcp','OpcUa','Mqtt');
CREATE TYPE tag_data_type AS ENUM ('Float','Int','Bool','String');

CREATE TABLE devices (
    id          UUID PRIMARY KEY,
    name        VARCHAR(64) NOT NULL,
    protocol    protocol_kind NOT NULL,
    location    VARCHAR(128),
    created_at  TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE tags (
    id          UUID PRIMARY KEY,
    device_id   UUID NOT NULL REFERENCES devices(id) ON DELETE CASCADE,
    address     VARCHAR(32) NOT NULL,
    data_type   tag_data_type NOT NULL,
    scaling     DOUBLE PRECISION,
    unit        VARCHAR(16)
);
CREATE INDEX idx_tags_device ON tags(device_id);
```

> **☑ TODO DB-1** — 将脚本写入并执行 `cargo sqlx migrate run`；CI 步骤 `cargo sqlx prepare --check` 确保查询与 DDL 一致。

---

### 1-G．前端 `package.json` 核心字段

```jsonc
{
  "name": "iot-web-ui",
  "scripts": {
    "dev": "vite --open",
    "build": "vite build",
    "lint": "eslint src --ext .vue,.ts",
    "preview": "vite preview"
  },
  "dependencies": {
    "vue": "^3.5.0",
    "pinia": "^2.1.5",
    "vue-router": "^4.3.0",
    "axios": "^1.7.0",
    "echarts": "^5.5.0"
  },
  "devDependencies": {
    "typescript": "^5.4.0",
    "vite": "^5.0.0",
    "@vitejs/plugin-vue": "^5.0.0",
    "@vue/eslint-config-typescript": "^12.0.0",
    "eslint": "^9.0.0"
  }
}
```

- **Axios 全局封装** `src/api/http.ts`：BaseURL = `import.meta.env.VITE_API_BASE`；请求添加 `Content-Type: application/json`，无鉴权。

- **WebSocket** `src/api/ws.ts`：`new WebSocket(`${VITE_WS_BASE}/telemetry?device_id=${id}`)`。


---

### 1-H．顶层 `Makefile`（剪裁版）

```makefile
# 运行后端 + 前端热重载
dev:
	@cargo run -p web-gw-api --features dev &
	@npm --prefix web-ui run dev

fmt:
	@cargo fmt --all
	@npm --prefix web-ui run lint -- --fix

test:
	@cargo test -p web-gw-api
	@npm --prefix web-ui run test:unit
```

---

### 1-I．Claude Code 执行 Checklist（段落 1 专属）

1. **创建 crate** `cargo new core/web-gw-api --bin` 并填充 _main.rs / bootstrap.rs / routes/_ 文件。

2. **修改 workspace** 加入新 crate；执行 `cargo check`.

3. **写迁移脚本** _DB-1_ 并 `sqlx migrate run`.

4. **生成 Vue 项目** `npm create vue@latest web-ui` → 替换 `package.json` 依赖；配置 `vite.config.ts` `proxy` 指到 `http://localhost:8080`.

5. **实现首批 Handler**（health & devices list）返回 mock JSON；前端通过 Axios 成功拉取并表格展示。

6. **GitHub Actions**：Rust + Node 双流水线均绿。


完成段落 1 后，你将得到：

- **可编译运行** 的 Actix 服务（仅核心路由占位）；

- **数据库表**：设备、点位已建；

- **Vue 前端**：打开 `http://localhost:5173` 能显示“设备列表 (mock)”；

- **一键脚本**：`make dev` 同时热重载前后端。


---
**段落 2：设备 / 点位 REST + WebSocket 完整实现、Driver-Manager 联动与前端页面交互规范**

> 本段让“网页可配置网关”真正跑通：**后端**可增删改查设备与点位并即时更新驱动，**前端**可通过表单管理数据并实时查看曲线。代码量直接可用；Claude Code 逐条 ☑ TODO 落地后即可看到端到端效果。

---

## 2-A 后端路由总览 & 注册

_文件_ `core/web-gw-api/src/routes/mod.rs`

```rust
pub fn register(cfg: &mut actix_web::web::ServiceConfig) {
    cfg.service(health::scope())
       .service(devices::scope())
       .service(tags::scope())
       .service(drivers::scope())
       .service(telemetry_ws::scope());
}
```

|模块|路径前缀|依赖|
|---|---|---|
|health.rs|`/health`|无|
|devices.rs|`/devices`|`DeviceRepo`, `DriverManager`|
|tags.rs|`/tags`|`TagRepo`, `DeviceRepo`|
|drivers.rs|`/drivers`|`DriverManager`|
|telemetry_ws.rs|`/ws/telemetry`|`FrameBus`|

---

## 2-B 仓储层 Repo 细节

> 用 **sqlx**；Trait 在 `core/infra-repo/`，实现注入到 `AppState`.

### 2-B-1 DeviceRepo

```rust
#[async_trait::async_trait]
pub trait DeviceRepo {
    async fn create(&self, dto: NewDevice) -> Result<Device>;
    async fn update(&self, id: Uuid, dto: DevicePatch) -> Result<Option<Device>>;
    async fn delete(&self, id: Uuid) -> Result<()>;
    async fn list(&self, limit:i64, offset:i64) -> Result<Vec<Device>>;
    async fn get(&self, id: Uuid) -> Result<Option<Device>>;
}
```

**☑ TODO BE-1** — 在 `infra/pg_repo/device.rs` 实现所有方法并添加单元测试。

### 2-B-2 TagRepo

```rust
#[async_trait::async_trait]
pub trait TagRepo {
    async fn create(&self, dto: NewTag) -> Result<TagPoint>;
    async fn list_by_device(&self, device_id:Uuid) -> Result<Vec<TagPoint>>;
    async fn delete(&self, id:Uuid) -> Result<()>;
}
```

**☑ TODO BE-2** — 实现并测试。

---

## 2-C 设备 Handler 示例（`routes/devices.rs`）

```rust
pub fn scope() -> Scope {
    web::scope("/devices")
        .route("", web::post().to(create))
        .route("", web::get().to(list))
        .route("/{id}", web::get().to(get))
        .route("/{id}", web::put().to(update))
        .route("/{id}", web::delete().to(delete))
}

async fn create(
    data: Data<AppState>,
    req: Json<DeviceCreateReq>,
) -> Result<impl Responder, ApiError> {
    let dev = data.device_repo.create(req.into_inner()).await?;
    // 注册驱动
    data.drivers.register(dev.protocol, dev.id).await?;
    Ok(HttpResponse::Created().json(DeviceVO::from(dev)))
}
```

- **更新**：修改 `protocol` 时需 `drivers.reload(proto)`；其余字段直接 `.update`.

- **删除**：先调用 `drivers.detach_all(device_id)` 再删库。

- 返回统一 `DeviceVO`.


**☑ TODO BE-3** — 写完其余 REST 方法 + 单元测试。

---

## 2-D 点位 Handler 核心（`routes/tags.rs`）

- 创建点位后无须通知驱动（驱动订阅 Frame-Bus 时读取 PG）。

- 列表接口支持 `device_id` 过滤；分页可选。


|Verb|`/tags`|Query|说明|
|---|---|---|---|
|GET|`?device_id=<uuid>`|列出设备全部点位||
|POST|body `NewTag`|新增||

**☑ TODO BE-4** — 完成实现与测试。

---

## 2-E 实时数据 WebSocket 桥（`telemetry_ws.rs`）

```rust
pub fn scope() -> actix_web::Scope {
    web::scope("/ws")
        .route("/telemetry", web::get().to(connect))
}

async fn connect(
    req: HttpRequest,
    stream: web::Payload,
    data: Data<AppState>,
) -> Result<HttpResponse, Error> {
    let device_id = req.query_string()
                       .split('=').nth(1)
                       .ok_or_else(|| ErrorBadRequest("device_id missing"))?
                       .parse::<Uuid>()?;
    let rx = frame_bus::subscribe(Filter::by_device(device_id))?;
    ws::start(TelemetryActor { rx }, &req, stream)
}

struct TelemetryActor { rx: FrameReceiver }

impl Actor for TelemetryActor { type Context = WsContext<Self>; }

impl StreamHandler<Result<BusFrame, BusError>> for TelemetryActor {
    fn handle(&mut self, item: Result<BusFrame, BusError>, ctx:&mut Self::Context) {
        if let Ok(BusFrame::Data(df)) = item {
            let msg = serde_json::to_string(&TelemetryMsg::from(df)).unwrap();
            ctx.text(msg);
        }
    }
}
```

- **Frame-Bus 过滤**：只发送指定 device 数据。

- **前端消息格式**：`{ ts: 162…, tag_id: "…", value: 12.34 }`.


**☑ TODO BE-5** — 实装 actor + 集成测试 (publish frame → WS recv)。

---

## 2-F 前端 Pinia Stores & API 调用

### 2-F-1 Axios 封装

```ts
const inst = axios.create({ baseURL: import.meta.env.VITE_API_BASE })
inst.interceptors.response.use(r=>r, e=>{
  ElMessage.error(e.response?.data?.detail || e.message)
  return Promise.reject(e)
})
export default inst
```

### 2-F-2 Device Store

```ts
export const useDeviceStore = defineStore('device', {
  state: ()=>({ list: [] as Device[] }),
  actions: {
    async fetch() { this.list = (await api.listDevices()).data },
    async create(d: DeviceCreateReq){ await api.createDevice({ data:d }); await this.fetch() },
    async update(id,d){ await api.updateDevice({ id, data:d }); await this.fetch() },
    async remove(id){ await api.deleteDevice({ id }); await this.fetch() },
  }
})
```

### 2-F-3 Telemetry Composition API Hook

```ts
export function useTelemetry(deviceId:Ref<string>){
  const series = ref<Record<string, number[]>>({})
  let ws:WebSocket|undefined
  watch(deviceId, id=>{
    if(ws) ws.close()
    ws = new WebSocket(`${import.meta.env.VITE_WS_BASE}/telemetry?device_id=${id}`)
    ws.onmessage = e=>{
      const {tag_id, ts, value} = JSON.parse(e.data)
      series.value[tag_id] ??= []
      series.value[tag_id].push(value)
    }
  }, { immediate:true })
  return { series }
}
```

---

## 2-G Vue 页面蓝图（Element-Plus UI 可替换）

### 2-G-1 `Device.vue`

_功能_：表格 + Drawer 表单。

```vue
<Table :data="devices">
  <template #actions="{row}">
    <Button @click="edit(row)">编辑</Button>
    <Button type="danger" @click="del(row.id)">删除</Button>
  </template>
</Table>
<Drawer v-model="drawer">
  <DeviceForm :model="form" @submit="onSubmit" />
</Drawer>
```

### 2-G-2 `Tag.vue`

- Select 设备 → 列点位 → 新增/删除

- 地址、数据类型、量程等字段校验。


### 2-G-3 `Dashboard.vue`

- 选择设备 → 勾选点位 → 实时图表（ECharts LineSeries）


```vue
<CheckboxGroup v-model="selected">
  <Checkbox v-for="t in tags" :label="t.id">{{t.address}}</Checkbox>
</CheckboxGroup>
<LineChart :series="chartSeries" />
```

```ts
const { series } = useTelemetry(deviceId)
const chartSeries = computed(()=> selected.value.map(id=>({
  name: id, type:'line', data: series.value[id] || []
})))
```

**☑ TODO FE-1** — 实现 3 个页面 + 路由 `/devices /tags /dashboard`.

---

## 2-H 测试矩阵

|层级|框架|用例|
|---|---|---|
|单元|Rust `cargo test`|BE-1, BE-2 Repo CRUD|
|集成|Rust `actix-web::test`|BE-3, BE-4 REST 200/404|
|WS|Rust `tokio-tungstenite`|BE-5 publish→recv|
|前端单元|Vitest|组件 emits / store actions|
|E2E|Playwright|添加设备→新增点位→查看实时曲线|

**☑ TODO CI-1** — GH Actions job `e2e.yml`：docker-compose up api + ws → playwright run。

---

## 2-I DevOps 扩展要点

|事项|最小实现|
|---|---|
|**日志**|`tracing` JSON → stdout；前端 `console.log` 移除|
|**监控**|`actix-web-prom` middleware → `/metrics`; Grafana 另配|
|**热更新**|`drivers.upload` 调 `DriverManager::load` 已在段落 1 定义；同一版本覆盖规则在段落 4|

---

### 2-J Claude Code Checklist（段落 2 专属）

|编号|动作|
|---|---|
|BE-1|实现 `PgDeviceRepo` + 测试|
|BE-2|实现 `PgTagRepo` + 测试|
|BE-3|完成 devices REST (create/list/get/update/delete)|
|BE-4|完成 tags REST (create/list/delete)|
|BE-5|实装 Telemetry WS actor + 测试|
|FE-1|新建 `Device.vue`, `Tag.vue`, `Dashboard.vue` + Pinia stores|
|CI-1|集成上表测试矩阵到 GitHub Actions|

执行完 Checklist：

- 打开 `http://localhost:5173` 可 **新增设备 → 配置点位 → 实时看曲线**；

- 新增或编辑设备时驱动自动注册/重载；

- 删除设备、点位立即生效（驱动 detach、Frame-Bus 停止推送）；

- 测试与 CI 全绿。


若本段任何细节需更深（如表单校验正则、ECharts 主题或驱动覆盖策略），请指出！


**段落 3：驱动（Driver）管理全栈实现——上传 / 热重载 / 卸载流程、ABI 规范、前端管理页、自动化测试与 DevOps**

> 目的：让用户在网页端**“选文件 → 上传 → 即刻生效”**，并在不重启网关的情况下升级或替换协议驱动。完成本段后，整个闭环将支持 **设备-点位-驱动** 三层动态配置。代码片段可直接落库；Claude Code 逐条 ☑ TODO 执行即可。

---

## 3-A 磁盘布局与工作区新增内容

```
Gateway_Rust/
├─ core/
│  ├─ driver-sdk/               # ➕ 公开给第三方编写驱动的 SDK
│  │   ├─ src/lib.rs
│  │   └─ Cargo.toml
│  ├─ driver-manager/           # ✅ 已存在；本段扩充
│  │   ├─ src/
│  │   │   ├─ lib.rs            // DriverManager
│  │   │   ├─ loader.rs         // *.so 装载逻辑  (新增)
│  │   │   ├─ registry.rs       // 已加载驱动表  (新增)
│  │   │   └─ watcher.rs        // inotify 热监视 (可关闭)
│  │   └─ tests/                // 用于 DM-T1~T4
│  └─ web-gw-api/               # 继续扩充
│      └─ src/routes/drivers.rs // 新增路由
├─ drivers/                     # 运行期动态库实际存放处
│  └─ {protocol}/{version}/libdriver.so
└─ web-ui/
    └─ src/pages/Driver.vue     # 管理界面
```

**☑ TODO DM-0** — 在根 `Cargo.toml` 的 `[workspace] members` 追加 `core/driver-sdk`.

---

## 3-B Driver ABI 规范（`driver-sdk`）

### 3-B-1 `Driver` trait

```rust
#[async_trait::async_trait]
pub trait Driver: Send + Sync {
    fn protocol(&self) -> ProtocolKind;
    fn version(&self) -> &'static str;
    async fn attach_device(&self, device_id: Uuid) -> Result<()>;
    async fn detach_device(&self, device_id: Uuid) -> Result<()>;
    async fn unload(&self) -> Result<()>;               // 收尾清理
}
```

### 3-B-2 宏 `declare_driver!`

```rust
// driver-sdk/src/lib.rs
#[macro_export]
macro_rules! declare_driver {
    (name = $name:expr, version = $ver:expr, driver = $ty:ty) => {
        #[no_mangle] pub extern "C" fn driver_entry() -> *mut dyn $crate::Driver {
            let drv: Box<dyn $crate::Driver> = Box::new(<$ty>::default());
            Box::into_raw(drv)
        }
        #[no_mangle] pub static DRIVER_NAME: &str = $name;
        #[no_mangle] pub static DRIVER_VERSION: &str = $ver;
        #[no_mangle] pub static DRIVER_API_VERSION: u8 = 1;
    };
}
```

_☑ TODO DM-1_ — 完成宏 & `DriverMeta { protocol, version, path }` 数据结构。

---

## 3-C Driver-Manager 运行期逻辑

### 3-C-1 基本操作

```rust
pub struct DriverManager {
    registry: DashMap<ProtocolKind, DriverEntry>,
}

pub struct DriverEntry {
    drv:    Arc<dyn Driver>,
    lib:    libloading::Library,      // 保证 .so 存活
    meta:   DriverMeta,
}
```

- `load(path)`

    1. `libloading::Library::new(path)`

    2. 获取 `driver_entry`、`DRIVER_NAME`, `DRIVER_VERSION`, `DRIVER_API_VERSION`.

    3. 如果 API≠1 → `ApiMismatch`.

    4. 若 registry 已有同 protocol：

        - 版本相同 → `AlreadyLoaded`.

        - 版本较旧 → 调 `unload()` → 替换条目。

    5. 调 `attach_device` 钩子对现有设备生效。

- `unload(protocol)`

    1. 找条目 → `drv.unload()` → `lib.close()`.

    2. 从 registry 移除。

- `list()` → `Vec<DriverInfo { protocol, version, loaded_at }>`


_☑ TODO DM-2_ — 完成 `loader.rs` & `registry.rs` 全功能、记录 `loaded_at`.

### 3-C-2 可选文件系统 Watch

- 默认关闭；`config.drivers.autowatch = true` 时，使用 `notify` crate watch `drivers/**/libdriver.so` `Create|Write` 事件并调 `reload(path)`。


---

## 3-D 数据库表 (PostgreSQL)

`schema/migrations/0004_driver_registry.sql`

```sql
CREATE TABLE driver_registry (
    protocol    protocol_kind PRIMARY KEY,
    version     VARCHAR(32) NOT NULL,
    loaded_at   TIMESTAMPTZ NOT NULL DEFAULT now()
);
```

- 每次 `load/reload/unload` 更新该表；供前端查询。


**☑ TODO DB-2** — 添加脚本并 `sqlx migrate run`.

---

## 3-E Actix 路由 (`routes/drivers.rs`)

```rust
pub fn scope() -> Scope {
    web::scope("/drivers")
        .route("",              web::get().to(list))
        .route("/upload",       web::post().to(upload))
        .route("/{protocol}",   web::delete().to(unload))
        .route("/{protocol}/reload", web::post().to(reload))
}

async fn upload(mut mp: Multipart, data: Data<AppState>)
    -> Result<impl Responder, ApiError> {
    let file = extract_single_file(&mut mp).await?;
    let temp = temp_file_path(&file).await?;             // 保存到 /tmp
    let proto = data.drivers.load(&temp).await?;
    move_to_final(proto, &temp, &data.cfg.drivers_dir).await?;
    Ok(HttpResponse::Ok().json(json!({
        "protocol": proto, "action":"loaded"
    })))
}
```

- `extract_single_file` 读取 `.so`；非 ELF / WASM 返回 400。

- `unload` → `drivers.unload(protocol)`; 同时删 PG 行 & 删除磁盘目录。


**☑ TODO BE-6** — 完整实现 4 个 Handler + 单元测试。

---

## 3-F 前端页面 `Driver.vue`

### 3-F-1 Pinia Store

```ts
export const useDriverStore = defineStore('driver', {
  state: ()=>({ list: [] as DriverInfo[] }),
  actions:{
    async fetch(){ this.list = (await api.listDrivers()).data },
    async upload(file:File){
      const form = new FormData(); form.append('file',file)
      await api.uploadDriver({ data:form }); await this.fetch()
    },
    async reload(proto:string){
      await api.reloadDriver({ protocol:proto }); await this.fetch()
    },
    async unload(proto:string){
      await api.deleteDriver({ protocol:proto }); await this.fetch()
    }
  }
})
```

### 3-F-2 组件骨架

```vue
<template>
  <Page title="驱动管理">
    <Upload accept=".so,.wasm" @success="onUpload" />
    <Table :data="drivers">
      <template #actions="{row}">
        <Button @click="reload(row.protocol)">热重载</Button>
        <Button type="danger" @click="unload(row.protocol)">卸载</Button>
      </template>
    </Table>
  </Page>
</template>

<script setup lang="ts">
const store = useDriverStore(); store.fetch()
const { drivers } = storeToRefs(store)
function onUpload(file){ store.upload(file.raw) }
function reload(p){ store.reload(p) }
function unload(p){ store.unload(p) }
</script>
```

**☑ TODO FE-2** — 完成页面样式、表单校验、路由 `/drivers`.

---

## 3-G 测试矩阵

|ID|描述|步骤|断言|
|---|---|---|---|
|DM-T1|**load_ok**|POST /upload libv1.so|200; PG version=v1|
|DM-T2|**reload_upgrade**|libv1 → libv2|列表 version=v2; v1 卸载 hook 调用一次|
|DM-T3|**same_version**|连续上传同文件|第一次 200; 第二次 409|
|DM-T4|**invalid_api**|上传 api_version=2|422 `driver.api_mismatch`|

> 后端测试用 `actix_web::test + assert_json`.

**☑ TODO TEST-1** — 在 `driver-manager/tests/` 与 `web-gw-api/tests/` 分别编写 DM-T1~T4。

---

## 3-H DevOps & CI

1. **GitHub Actions** 新 Job `drivers-tests`:

    ```yaml
    - name: Run driver tests
      run: cargo test -p driver-manager
    ```

2. **Dockerfile**：

    ```Dockerfile
    RUN mkdir -p /app/drivers
    COPY drivers /app/drivers        # 预置官方驱动
    ```

3. **Compose**：若使用热监视，挂载 `drivers:/opt/gw/drivers` 为可写卷。


---

### 3-I Claude Code Checklist（段落 3 专属）

|编号|内容|
|---|---|
|DM-1|实现 `driver-sdk` 宏与元数据|
|DM-2|完成 `DriverManager` loader / unload / list|
|DB-2|添加 `driver_registry` 表迁移 & 运行|
|BE-6|路由 `/drivers` 四接口 + 测试|
|FE-2|`Driver.vue` 页面 + Store|
|TEST-1|DM-T1 ~ DM-T4 全部通过|
|CI|新增 Job `drivers-tests`|

---

**完成本段后，你将得到：**

- **网页端**：上传 `.so` ☞ 立即出现在“驱动列表”；点“热重载”文字闪现“已更新”。

- **后端**：DriverManager 在内存表 & PG 中同步更新，已跑的设备自动切换到新版驱动。

- **CI 桥接**：每次 PR 自动编译驱动、跑四个核心用例，防回归。


> 下一段（段落 4）建议实现 **InfluxDB 历史数据查询与统计接口**，配套“历史曲线 / 报表”前端视图。如需先处理其他模块，请告诉我！

**段落 4：InfluxDB 历史数据查询与统计接口——后端实现、前端报表视图、测试与运维**

> 目标：让用户在网页端**选时间范围 → 查看历史曲线 / 最大-最小-平均 / 导出 CSV**。完成本段后，全栈即可同时处理 **实时(WS) + 历史(HTTP)** 数据。Claude Code 依照 ☑ TODO 列表执行即可落地。

---

## 4-A 测点数据存储规范回顾

|属性|约定|
|---|---|
|**Influx 2.x** bucket|`telemetry`|
|Measurement|`tag_data`|
|Tags|`device_id`、`tag_id`|
|Fields|`f_value` (float)，`i_value` (int)，`b_value` (bool)，`s_value` (string)|
|时间戳|驱动层使用纳秒精度 `epoch_ns`|
|保留策略|30 天（生产可调）；0 = 永久保留|

> **写入示例（Line-Protocol）**
>
> ```
> tag_data,device_id=7f..,tag_id=35.. f_value=12.34 1721981047000000000
> ```

---

## 4-B API 路由设计

_文件_ `core/web-gw-api/src/routes/history.rs`

|Verb|Path|说明|Handler|
|---|---|---|---|
|`GET`|`/api/v1/history/query`|原始序列|`history::query_series`|
|`GET`|`/api/v1/history/stats`|统计聚合|`history::query_stats`|
|`GET`|`/api/v1/history/export`|CSV 下载|`history::export_csv`|

### 4-B-1 Query 参数

|参数|类型|必填|说明|
|---|---|---|---|
|`device_id`|UUID|✔|设备|
|`tag_id`|UUID|✔|点位|
|`from`|RFC3339|✔|起始时间|
|`to`|RFC3339|✔|结束时间|
|`step`|Duration|✖|down-sample 粒度，默认 1 s|
|`agg`|enum|stats 接口必填|`mean`/`min`/`max`/`sum`|

> ⚠ **鉴权**暂不启用；上线前并入段落 7。

---

## 4-C DTO 定义（`dto.rs`）

```rust
#[derive(Deserialize)]
pub struct HistoryQuery {
    pub device_id: Uuid,
    pub tag_id:    Uuid,
    pub from:      DateTime<Utc>,
    pub to:        DateTime<Utc>,
    pub step:      Option<humantime::Duration>,
}
#[derive(Serialize)]
pub struct SeriesPoint { pub ts: i64, pub value: f64 }

#[derive(Deserialize)]
pub struct StatsQuery {
    #[serde(flatten)] pub base: HistoryQuery,
    pub agg: StatsKind,              // mean|min|max|sum
}
#[derive(Serialize)]
pub struct StatsResp {
    pub device_id: Uuid,
    pub tag_id:    Uuid,
    pub agg:       StatsKind,
    pub value:     f64,
}
```

**☑ TODO BE-7** — 在 `dto.rs` 写枚举 `StatsKind` + `FromStr`.

---

## 4-D Influx 查询实现

### 4-D-1 原始序列 (down-sample)

```rust
async fn query_series(
    data: Data<AppState>,
    q: Query<HistoryQuery>,
) -> Result<impl Responder, ApiError> {
    let step = q.step.unwrap_or_else(|| humantime::Duration::from_secs(1));
    let flux = format!(r#"
      from(bucket:"telemetry")
      |> range(start: time(v: "{from}"), stop: time(v: "{to}"))
      |> filter(fn:(r)=> r.device_id=="{dev}" and r.tag_id=="{tag}")
      |> aggregateWindow(every: {step}, fn: mean, createEmpty: false)
      |> yield(name:"mean")
    "#,
      from=q.from.to_rfc3339(), to=q.to.to_rfc3339(),
      dev=q.device_id, tag=q.tag_id, step=step
    );
    let result = data.influx.query::<SeriesPoint>(flux).await?;
    Ok(Json(result))
}
```

### 4-D-2 统计聚合

```rust
let func = match q.agg { Mean=>"mean", Min=>"min", Max=>"max", Sum=>"sum" };
let flux = format!(r#"
  from(bucket:"telemetry")
  |> range(start: time(v: "{from}"), stop: time(v: "{to}"))
  |> filter(fn:(r)=> r.device_id=="{dev}" and r.tag_id=="{tag}")
  |> {func}()
"#, ... );
```

### 4-D-3 CSV 导出

- 调用与 `query_series` 相同 flux；使用 `influxdb2::Client::query_csv`。

- 返回 `Content-Type: text/csv; charset=utf-8;`，文件名 `device_<id>_<from>_<to>.csv`.


**☑ TODO BE-8** — 实现 `query_series` / `query_stats` / `export_csv` 三 Handler 完整错误链。

---

## 4-E 前端页面与 Store

### 4-E-1 Store `history.ts`

```ts
export const useHistoryStore = defineStore('history', {
  state: ()=>({
    points:{} as Record<string, SeriesPoint[]>,   // key = tagId
    stats:{}  as Record<string, number>,
  }),
  actions:{
    async fetchSeries(params:HistoryQuery){
      const { data } = await api.querySeries(params)
      this.points[params.tag_id] = data
    },
    async fetchStats(params:StatsQuery){
      const { data } = await api.queryStats(params)
      this.stats[`${params.tag_id}-${params.agg}`] = data.value
    },
    async exportCsv(p:HistoryQuery){
      const blob = (await api.exportCsv({ params:p, responseType:'blob'})).data
      saveAs(blob, 'history.csv')
    }
  }
})
```

### 4-E-2 页面 `History.vue`

```vue
<DateTimePicker v-model="range" />
<SelectDevice v-model="deviceId" />
<SelectTag v-model="tagId" />
<Button @click="load">查询</Button>
<Button @click="exportCsv">导出 CSV</Button>

<LineChart :series="series" />

<Card title="统计">
  <p>平均值：{{stats.mean}}</p>
  <p>最大值：{{stats.max}}</p>
</Card>
```

```ts
const store = useHistoryStore()
async function load(){
  await store.fetchSeries({...params, step:'1s'})
  await store.fetchStats({...params, agg:'mean'})
  await store.fetchStats({...params, agg:'max'})
}
const series = computed(()=> [{
  name:'value', type:'line',
  data: store.points[tagId.value]?.map(p=>[p.ts,p.value]) || []
}])
const stats = computed(()=> ({
  mean: store.stats[`${tagId.value}-mean`] ?? '—',
  max:  store.stats[`${tagId.value}-max`]  ?? '—'
}))
```

**☑ TODO FE-3** — 完成 `History.vue`、路由 `/history`、日期选择器国际化。

---

## 4-F 测试计划

|层级|框架|用例|
|---|---|---|
|单元|Rust|BE-7 enum parse、Flux 构造|
|集成|Rust + `testcontainers`|写入 Influx → 调 `/history/query` ↔ 校验 JSON|
|导出|Rust|`/history/export` 返回 CSV 内容-Type|
|前端单元|Vitest|Store fetch → 状态写入|
|前端 E2E|Playwright|选设备+时间 → 曲线渲染 ≥1 点 →|

**☑ TODO TEST-2** — 编写后端集成测试 `history_e2e.rs`.

---

## 4-G 运维与性能优化

|项|配置 / 建议|
|---|---|
|**Influx Token**|置于 `INFLUX_TOKEN` 环境变量；ApiCfg 只存 URL|
|**Retention Policy**|`influx bucket update telemetry --retention 720h`|
|**Downsampling**|每日 Task 写入 `telemetry_1m` bucket (`aggregateWindow 1m`)|
|**backup**|`influx backup /backups/influx/$(date) -b telemetry`|
|**索引 / Cardinality**|Tag 存 UUID，避免高基数字段；无 location 等动态 Tag|

监控指标（Prometheus）：

- `history_query_duration_seconds_bucket` (Histogram)

- `influx_http_requests_total`


**☑ TODO OPS-1** — 在 `web-gw-api/src/metrics.rs` 导出 Histogram。

---

## 4-H CI/CD 增量

1. **Service Injection**：GitHub Actions `services: influxdb:2.7-alpine`，预创建 bucket & token：

    ```yaml
    influxdb:
      image: influxdb:2.7
      env:
        - DOCKER_INFLUXDB_INIT_USERNAME=ci
        - DOCKER_INFLUXDB_INIT_PASSWORD=ci123
        - DOCKER_INFLUXDB_INIT_ORG=acme
        - DOCKER_INFLUXDB_INIT_BUCKET=telemetry
    ```

2. **Job** `history-tests`：运行 TEST-2 集成脚本。


---

### 4-I Claude Code Checklist（段落 4 专属）

|编号|任务|
|---|---|
|BE-7|DTO `StatsKind` + handler 参数解析|
|BE-8|实现 3 Handler（query_series / query_stats / export_csv）|
|FE-3|新建 `History.vue` + store + 路由|
|TEST-2|Influx 集成测试覆盖 JSON 与 CSV|
|OPS-1|Prometheus Histogram 导出|
|CI|新 Job `history-tests` 启动 Influx 服务|

---

**完成本段后，你将得到：**

- **后端**：`/history/query` ~ 50 ms 完成 1 小时数据查询，`/history/stats` 支持 mean/min/max/sum。

- **前端**：时间选择 → 曲线即时渲染；“导出 CSV” 一键下载。

- **监控**：Prometheus 可见查询延迟分布；Influx bucket 30 天滚动。


> 下一段（段落 5，若需要）可覆盖 **告警 & 报警（阈值→通知）** 或 **运维监控仪表盘（Grafana JSON 模板）**。如有不同优先级，请告知！


**段落 5：报警（Alerting）与通知系统——规则建模、评估引擎、后端 API、前端可视化、运维与测试**

> 目标：让用户在网页端 **“配置阈值 → 保存规则 → 实时/周期触发 → 收到邮件或 Web 推送”**。完成本段后，平台具备 **实时告警 + 历史报警记录 + 多渠道通知** 的闭环。内容按 **磁盘布局 → 数据模型 → 评估引擎 → API → 前端 → 测试 → 运维** 逐层展开。所有 ☑ TODO 对应可直接编码的任务。

---

## 5-A 目录增量（核心代码与服务）

```
Gateway_Rust/
├─ core/
│  ├─ alert-engine/             # ➕ Tokio 后台任务，评估规则
│  │   ├─ src/
│  │   │   ├─ main.rs
│  │   │   ├─ engine.rs         // 规则轮询 + 推送
│  │   │   └─ notifier.rs       // Email / Webhook / WS
│  │   └─ Cargo.toml
│  └─ web-gw-api/
│      └─ src/routes/alerts.rs  // 规则 CRUD & 历史查询
├─ schema/migrations/
│  └─ 0005_alerts.sql           # ➕ 新建表
├─ web-ui/
│  └─ src/pages/
│      ├─ AlertRule.vue         # 规则管理
│      └─ AlertHistory.vue      # 报警记录
└─ .github/workflows/
    └─ alerts-tests.yml         # CI
```

---

## 5-B 数据库模型（PostgreSQL：0005_alerts.sql）

```sql
CREATE TYPE compare_op AS ENUM ('GT','LT','GTE','LTE','EQ','NE');
CREATE TYPE alert_level AS ENUM ('INFO','WARN','CRIT');

CREATE TABLE alert_rules (
    id           UUID PRIMARY KEY,
    name         VARCHAR(64) NOT NULL,
    device_id    UUID,
    tag_id       UUID,
    op           compare_op  NOT NULL,
    threshold    DOUBLE PRECISION,
    level        alert_level NOT NULL DEFAULT 'WARN',
    eval_every   INTERVAL    NOT NULL DEFAULT INTERVAL '10s',
    enabled      BOOLEAN     NOT NULL DEFAULT TRUE,
    created_at   TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE alert_history (
    id           UUID PRIMARY KEY,
    rule_id      UUID REFERENCES alert_rules(id) ON DELETE CASCADE,
    fired_at     TIMESTAMPTZ NOT NULL,
    value        DOUBLE PRECISION,
    level        alert_level,
    message      TEXT
);
```

_☑ TODO DB-3_ — 写脚本并执行 `sqlx migrate run`; 更新 CI `cargo sqlx prepare`.

---

## 5-C Alert-Engine：评估流程

### 5-C-1 核心算法 (`engine.rs`)

```rust
/// 每条规则独立 Tokio task；超时后重启
async fn eval_loop(rule: AlertRule, deps: Deps) -> Result<()> {
    let mut ticker = tokio::time::interval(rule.eval_every);
    loop {
        ticker.tick().await;
        if !rule.enabled { continue; }
        let v = deps.influx.query_f64(latest_flux(&rule)).await?;
        if compare(v, rule.op, rule.threshold) {
            let evt = AlertEvent::new(rule.clone(), v);
            deps.notifier.dispatch(evt.clone()).await?;
            deps.pg.insert_history(evt).await?;
        }
    }
}
```

- **最新值 Flux**

    ````flux
    from(bucket:"telemetry")
      |> range(start:-1m)
      |> filter(fn:(r)=> r.device_id=="${rule.device_id}"
                        and r.tag_id=="${rule.tag_id}")
      |> last()
      |> findColumn(fn:(key) => true, column:"_value")
    ``` :contentReference[oaicite:0]{index=0}  
    ````

- **同时支持 aggregateWindow**：若 `eval_every > 1m` 则改用 `aggregateWindow(every: rule.eval_every, fn: mean)`。

- **compare**：GT/LT/GTE/LTE/EQ/NE。


**☑ TODO AE-1** — 实现 `eval_loop`, `latest_flux`, `compare`, `AlertEvent`.

### 5-C-2 任务调度 (`main.rs`)

```rust
let rules = pg.load_all_rules().await?;
for r in rules { spawn_eval(r, deps.clone()) }
watch_pg_notify("alert_rule_changed", move |rule_id| {
    // reload / stop-then-start
});
```

- 使用 `LISTEN/NOTIFY` 监听规则表变更，热重启对应任务。

- **失败回退**：连续 5 次查询错误 → 将 Rule `enabled=false`, 写历史记录 level=CRIT。


**☑ TODO AE-2** — 实现 `spawn_eval` + PG `LISTEN` 热更新。

### 5-C-3 通知器 (`notifier.rs`)

|渠道|配置键|说明|
|---|---|---|
|Email (SMTP)|`alerts.smtp_*`|简易文本；多收件人逗号分割|
|Webhook (POST JSON)|`alerts.webhook_url`|10 s 超时|
|Internal WS|`alert_ws_tx`|发入 `tokio::broadcast::Sender` 给前端|

```rust
async fn dispatch(&self, e:AlertEvent) -> Result<()> {
    if let Some(tx) = &self.ws { let _=tx.send(e.clone()); }
    if let Some(cfg) = &self.smtp { send_email(cfg,&e).await?; }
    if let Some(url) = &self.webhook { post_json(url,&e).await?; }
    Ok(())
}
```

**☑ TODO AE-3** — 实现 3 种渠道 + 单元测试 (mock SMTP/Webhook)。

---

## 5-D Actix API (`routes/alerts.rs`)

|Verb|Path|Body|说明|
|---|---|---|---|
|`GET`|`/api/v1/alerts/rules`|–|列表|
|`POST`|`/api/v1/alerts/rules`|`NewRuleReq`|新增|
|`PUT`|`/api/v1/alerts/rules/{id}`|`PatchRuleReq`|更新|
|`DELETE`|`/api/v1/alerts/rules/{id}`|–|删除|
|`GET`|`/api/v1/alerts/history`|`device_id`, `from`, `to`|查询历史|
|`WS`|`/ws/alerts`|–|实时推送 AlertEvent|

### 5-D-1 DTO（摘录）

```rust
#[derive(Deserialize)] pub struct NewRuleReq {
    pub name: String,
    pub device_id: Uuid,
    pub tag_id: Uuid,
    pub op: CompareOp,
    pub threshold: f64,
    pub level: AlertLevel,
    pub eval_every: humantime::Duration,
}
```

- **验证**：`threshold` 必须符合 `data_type`（Bool → 0|1…）。


**☑ TODO BE-9** — 实现 CRUD + WS handler；其中 POST 调用 `pg.insert_rule` 并 `NOTIFY`.

---

## 5-E 前端实现

### 5-E-1 Pinia Store `alert.ts`

```ts
export const useAlertStore = defineStore('alert',{
  state:()=>({
    rules:[] as AlertRuleVO[],
    events:[] as AlertEventVO[]
  }),
  actions:{
    async fetchRules(){ this.rules=(await api.listRules()).data },
    async createRule(r){ await api.createRule({data:r}); await this.fetchRules() },
    async updateRule(id,r){ await api.updateRule({id,data:r}); await this.fetchRules() },
    async deleteRule(id){ await api.deleteRule({id}); await this.fetchRules() },
    watchEvents(){
      const ws=new WebSocket(`${VITE_WS_BASE}/alerts`)
      ws.onmessage=e=> this.events.unshift(JSON.parse(e.data))
    }
  }
})
```

### 5-E-2 组件概览

|组件|功能|
|---|---|
|`AlertRule.vue`|表格→新增/编辑抽屉；下拉选择设备+点位→ op(> < = !=) → 阈值 → 频率|
|`AlertHistory.vue`|时间范围+设备过滤 → 列表+分页；点击行显示趋势 mini-chart|
|Navbar 🔔 icon|显示 `store.events[0..5]`；红点 = `events.some(e=>e.level==='CRIT')`|

**☑ TODO FE-4** — 完成两个页面、表单校验、通知红点动画。

---

## 5-F 测试矩阵

|ID|场景|步骤|断言|
|---|---|---|---|
|AE-T1|规则 GT 触发|写入值=120 > 100|history 插入；WS 收到|
|AE-T2|阈值未触发|写入 80|无 history|
|AE-T3|规则禁用|PATCH enabled=false|Engine 停止；写入 120 仍无 record|
|AE-T4|SMTP failover|断网→邮件失败|history level=CRIT；Engine 重试 3 次后放弃|

_框架_：后端集成测试使用 `testcontainers + smtp4dev + wiremock`。

**☑ TODO TEST-3** — 实现 AE-T1~T4。

---

## 5-G 运维与指标

|指标|类型|标签|
|---|---|---|
|`alert_rules_active`|Gauge|level|
|`alert_evaluations_total`|Counter|result=triggered/ok|
|`alert_notify_failures_total`|Counter|channel|

- 暴露在 **alert-engine** `/metrics`；Prometheus scrape。

- Grafana JSON 模板：`Alert Overview`（规则数、近24 h 触发数、通知失败率）。


**☑ TODO OPS-2** — 实现 metrics (use `metrics` crate) + 提交 `grafana/alert_overview.json`.

---

## 5-H CI/CD 增量

1. **GitHub Actions services**：smtp4dev for SMTP channel.

2. **Job** `alerts-tests`：spin Influx+Postgres+smtp4dev → run TEST-3.

3. **Docker Compose**：新增 `alert-engine` service，depends_on Postgres, Influx.


---

### 5-I Claude Code Checklist（段落 5 专属）

|编号|任务|
|---|---|
|DB-3|创建 `alert_rules` / `alert_history` 表|
|AE-1|实现 `eval_loop` & Flux builder|
|AE-2|PG `LISTEN` 热更新 & task spawn|
|AE-3|SMTP/Webhook/WS 通知器|
|BE-9|`/alerts/*` REST + WS|
|FE-4|`AlertRule.vue` / `AlertHistory.vue` + 红点|
|TEST-3|AE-T1~T4 通过|
|OPS-2|Prometheus 指标 + Grafana JSON|
|CI|新 Job `alerts-tests`|

---

**完成本段后，你将得到：**

- **网页端**：在“报警规则”页添加规则，如“电流 > 100 A 每 10 s 检测”；触发时浏览器红点弹出、邮件/Webhook 同步。

- **后端**：`alert-engine` 每条规则独立协程；Rule CRUD 即时生效；失败自动降级。

- **监控**：Grafana “Alert Overview” 看 24 h 报警。


### **段落 6：监控与日志收集部署（Prometheus + Grafana + Loki）**

> 本段为 _Gateway Rust_ 提供**可观测性基座**：统一的性能指标、报警指标、日志检索和仪表盘。目标是让工程师能够在本地或服务器环境通过手动启动的监控栈快速定位性能瓶颈、接口错误或驱动异常。遵守本段后，所有核心组件均暴露 Prometheus 指标及结构化日志，Grafana 一键导入仪表盘，Loki 支撑全文检索。

---

#### 6-A 组件与版本锁定

|组件|镜像 Tag|端口|作用|
|---|---|---|---|
|**Prometheus**|`prom/prometheus:2.52.0`|`9090`|指标采集与聚合|
|**Grafana**|`grafana/grafana:10.4.0`|`3000`|可视化仪表盘|
|**Loki**|`grafana/loki:3.0.0`|`3100`|日志聚合|
|**Promtail**|`grafana/promtail:3.0.0`|–|将容器日志推送至 Loki|

_所有版本写死，不得使用 `latest`_。

---

#### 6-B 新增 Compose 文件 `docker/compose.monitor.yml`

```yaml
services:
  prometheus:
    image: prom/prometheus:2.52.0
    volumes:
      - ./monitor/prometheus.yml:/etc/prometheus/prometheus.yml
    ports: ["9090:9090"]

  grafana:
    image: grafana/grafana:10.4.0
    volumes:
      - grafana_data:/var/lib/grafana
      - ./monitor/grafana_dashboards:/var/lib/grafana/dashboards
    environment:
      - GF_DASHBOARDS_DEFAULT_HOME_DASHBOARD_PATH=/var/lib/grafana/dashboards/overview.json
    ports: ["3000:3000"]

  loki:
    image: grafana/loki:3.0.0
    command: -config.file=/etc/loki/local-config.yaml
    ports: ["3100:3100"]

  promtail:
    image: grafana/promtail:3.0.0
    volumes:
      - /var/lib/docker/containers:/var/lib/docker/containers:ro
      - ./monitor/promtail-config.yml:/etc/promtail/config.yml
    command: -config.file=/etc/promtail/config.yml

volumes:
  grafana_data:
```

> 手动启动命令：
>
> ```bash
> docker compose -f docker/compose.monitor.yml up
> ```

---

#### 6-C Prometheus 抓取配置 `monitor/prometheus.yml`

```yaml
global:
  scrape_interval: 10s
scrape_configs:
  - job_name: api
    static_configs:
      - targets: ['host.docker.internal:8080']   # Actix API
  - job_name: alert_engine
    static_configs:
      - targets: ['host.docker.internal:9500']
  - job_name: postgres
    static_configs:
      - targets: ['postgres:9187']              # pg_exporter（可选）
  - job_name: influxdb
    metrics_path: /metrics
    static_configs:
      - targets: ['influxdb:8086']
  - job_name: docker
    static_configs:
      - targets: ['host.docker.internal:9323']   # cAdvisor / node-exporter
```

_☑ TODO MON-1_ —— Claude Code 需在 API、Alert-Engine 二进制启动时自动开放 `/metrics`（见 6-E）。

---

#### 6-D 日志统一：`tracing` → Loki

1. **JSON 输出**：所有 Rust 服务设置

    ```rust
    tracing_subscriber::fmt()
        .json()
        .with_max_level(cfg.log_level.parse()?)
        .with_current_span(true)
        .with_span_events(FmtSpan::CLOSE)
        .init();
    ```

2. **日志路由**：Docker 通过 Promtail 读取容器 stdout；本地裸运行建议使用 `RUST_LOG=json` + file 路径，并调整 `promtail-config.yml` 文件中的 `__path__`.


---

#### 6-E 指标导出（Rust 端）

```rust
// Cargo.toml
metrics = "0.21"
metrics-exporter-prometheus = "0.14"

// main.rs
let recorder = PrometheusBuilder::new()
    .with_http_listener(cfg.metrics_addr)   // e.g., 0.0.0.0:8081
    .install_recorder()?;
```

|模块|指标|说明|
|---|---|---|
|**API**|`http_requests_total`, `http_response_time_seconds` (Histogram)|label: method, path, status|
|**DriverManager**|`drivers_loaded_total`, `driver_reload_duration_seconds`|label: protocol|
|**Alert-Engine**|`alert_evaluations_total`, `alert_trigger_total`|label: result=ok/fired|
|**DB**|`sqlx_query_time_seconds`|label: query_hash|

_☑ TODO MON-2_ —— 在各 crate 引入 `#[instrument]` + `metrics::increment_counter! / histogram!`。

---

#### 6-F Grafana Dashboards

1. **overview.json** —— 系统概览

    - API QPS / P95 / Error Rate

    - Alert 触发数

    - Influx write & query QPS

2. **driver.json** —— 驱动加载与热重载耗时

3. **alert.json** —— 每小时报警统计 + Top N 设备


放置于 `monitor/grafana_dashboards/`。Grafana 启动时自动导入。

_☑ TODO MON-3_ —— Claude Code 需提交 `overview.json` 初版模板（可导入即显）。

---

#### 6-G 常见手工操作指南（写入 `docs/monitoring.md`）

|目标|命令|
|---|---|
|查看 API 指标|`curl [http://localhost:8081/metrics](http://localhost:8081/metrics)|
|Grafana 默认账户|`admin / admin`；首次登录强制修改|
|Loki 查询示例|`{container="web-gw-api"}|
|清理监控栈|`docker compose -f docker/compose.monitor.yml down -v`|

_☑ TODO MON-4_ —— 在文档新增章节并填充上述表格。

---

#### 6-H 变更通告模板

若 Claude Code 调整或新增指标路径、端口、dashboard，需附：

```
📣 Monitoring-Update
新增指标: drivers_loaded_total{protocol}
Grafana 面板: driver.json v0.2
手动刷新: docker compose -f docker/compose.monitor.yml up -d prometheus grafana
```

---

#### 6-I 综合 TODO 列表（段落 6 专属）

|编号|内容|
|---|---|
|MON-1|在 `web-gw-api`, `alert-engine` 暴露 `/metrics` listener|
|MON-2|插入 `metrics` 宏到 API 中间件、驱动重载、报警评估逻辑|
|MON-3|提交 Grafana `overview.json` 初版|
|MON-4|更新 `docs/monitoring.md` 手册|
|_手动操作_|用户自行 `docker compose -f docker/compose.monitor.yml up`|

---
### **段落 7：端到端调试手册（接口排错与性能剖析）**

> 本段提供一套 **“从浏览器点击到驱动返回”** 的完整调试流程与问题定位指南，避免出现接口不通、数据错位或性能瓶颈时耗费大量人工排查。覆盖 **HTTP / WebSocket / Frame-Bus / 驱动 / 数据库 / 指标 / 日志** 六大链路。所有工程师与自动化代理（Claude Code）在开发或验收过程中应严格按照本手册执行排错步骤。

---

#### 7-A 准备工作

|步骤|命令|说明|
|---|---|---|
|① 启动基础栈|`make run-dev`|Postgres / Influx / NATS 容器就绪|
|② 启动后端|`cargo run -p web-gw-api`|在第二终端；观察 log `Server running @ 0.0.0.0:8080`|
|③ 启动前端|`npm --prefix web-ui run dev`|打开 [http://localhost:5173](http://localhost:5173/)|
|④ 启动监控|`docker compose -f docker/compose.monitor.yml up -d`|Grafana 端口 `3000`，Prometheus `9090`|
|⑤ 浏览器插件|安装 **REST Client** 或 **Thunder Client**，用于快速重放 API||

---

#### 7-B 接口排错分层流程

> **出现 4xx/5xx、WebSocket 未连通或前端空白时，依次执行下列步骤**：

1. **浏览器 DevTools**

    - Network → 找到失败请求

    - 判断：

        - 无请求发出 → 检查前端 `env` API URL 或路由路径

        - 状态码 4xx → 后端参数校验不通过；查看 Response `detail`

        - 状态码 5xx → 继续下一步

2. **后端日志（Loki 或 stdout）**

    - 查询 `{container="web-gw-api"} |= "error" |= "X-Trace-Id=<id>"`

    - 若未找到 `Trace-Id`，则说明请求未达到后端；回到①

3. **Prometheus 指标**

    - 打开 [http://localhost:9090/graph](http://localhost:9090/graph) 执行

        ```
        http_response_time_seconds_count{path="/api/v1/devices"}
        ```

    - 若计数为 0，说明 Handler 未注册或路由冲突。

4. **sqlx 查询时间过长**

    - 查询

        ```
        sqlx_query_time_seconds_bucket{le="0.5"}
        ```

    - 若高分位 >0.5 秒，检查索引或 SQL。

5. **Frame-Bus ➜ 驱动**

    - 发送控制命令后无反馈 → 运行

        ```
        frame_bus_lag{device_id="<uuid>"}
        ```

    - Lag >1 则环形缓冲溢出；需扩环或减少推送频率。

6. **Influx 数据缺失**

    - 使用 Influx UI 或 `influx query` 检查写入；若无点，排查驱动。

7. **WebSocket 实时流异常**

    - 浏览器 WS 面板：Ping/Pong 正常但无数据 → 检查 Step 5 与 Influx。

8. **前端类型错误**

    - 控制台报 `zod` schema fail → 更新后端 DTO 或前端 OpenAPI 类型。


---

#### 7-C 性能剖析（API P95 > 300 ms 时）

1. **curl Benchmark**

    ```bash
    curl -w "total:%{time_total}\n" -H "X-Trace-Id:debug" \
      http://localhost:8080/api/v1/history/query?... -o /dev/null
    ```

    - 若 `time_total` > 0.3 s，继续下一步。

2. **pprof** (dev feature)

    - 启动 API `cargo run -p web-gw-api --features dev-prof`

    - 浏览 [http://localhost:6060/pprof](http://localhost:6060/pprof) 下载火焰图。

3. **热点分类**

    - SQL >60 % → 新索引或分页；Influx 聚合 → down-sample。

    - JSON 序列化 >20 % → 打开 `serde_json::to_writer` + `rustc lto`。

    - 锁争用 → 粒度化 Mutex 或改 `dashmap`.


---

#### 7-D 前端实时流缺口调试

|症状|排查点|修复建议|
|---|---|---|
|曲线断点|WS 断→重连成功后 `series` 仍空|`useTelemetry` 应在 `onclose` 5 s 后自动重连|
|多设备混流|返回 `device_id` 不匹配|后端 `Filter::by_device` 实现是否错误|
|点位顺序错乱|ECharts X 轴为时间但数据未排序|在 Hook 中 `array.sort((a,b)=>a.ts-b.ts)`|

---

#### 7-E 驱动热重载回归验证

1. 上传新 `.so` → 接口返回 `{"action":"loaded"}`。

2. Prometheus `drivers_loaded_total{protocol="ModbusTcp"}` +1。

3. Device `attach` 后 30 s 内，Grafana Driver 面板 “Reload Duration” 曲线更新。

4. 历史查询接口仍返回连续数据；否则复查驱动指针安全。


---

#### 7-F 常用 CLI 摘要（写入 `docs/debug_cheatsheet.md`）

|场景|命令|
|---|---|
|Postgres shell|`docker exec -it pg psql -U postgres iot`|
|Influx shell|`docker exec -it influxdb influx`|
|Frame-Bus dump|`cargo run -p frame-bus -- dump --device <id>`|
|Tail 20 条错误日志|`docker logs --tail 20 web-gw-api|
|手动推数据到 Influx|`curl -XPOST $INFLUX/write -d 'tag_data,device_id=... f_value=1 0'`|

_☑ TODO DEBUG-1_ — Claude Code 需生成 `docs/debug_cheatsheet.md` 填充上表。

---

#### 7-G 完成清单（段落 7 专属）

|编号|动作|
|---|---|
|DEBUG-1|创建/更新 `docs/debug_cheatsheet.md`|
|–|若新增排查步骤或命令，请同步到此手册|
